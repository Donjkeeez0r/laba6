'''
Задание состоит из двух частей.
1 часть – написать программу в соответствии со своим вариантом задания. Написать 2 варианта формирования (алгоритмический и с помощью функций Питона), сравнив по времени их выполнение.
2 часть – усложнить написанную программу, введя по своему усмотрению в условие минимум одно ограничение на характеристики объектов (которое будет сокращать количество переборов)  и целевую функцию для нахождения оптимального  решения.

Пароль состоит из 6 символов. Первые 2 – латинские буквы, остальные - латинские буквы или цифры. Составьте все возможные пароли.
'''

import string
import random
import timeit

# 1 часть
# Функция для генерации пароля с использованием алгоритмического подхода
def generate_password_algorithm(num_passwords):
    passwords = []
    for _ in range(num_passwords):
        password = ''
        password += random.choice(string.ascii_letters)                   # Первый символ - латинская буква
        password += random.choice(string.ascii_letters)                   # Второй символ - латинская буква
        password += random.choice(string.ascii_letters + string.digits)   # Третий символ - латинская буква или цифра
        password += random.choice(string.ascii_letters + string.digits)   # Четвертый символ - латинская буква или цифра
        password += random.choice(string.ascii_letters + string.digits)   # Пятый символ - латинская буква или цифра
        password += random.choice(string.ascii_letters + string.digits)   # Шестой символ - латинская буква или цифра
        passwords.append(password)
    return passwords

# Функция для генерации пароля с использованием функций Python
def generate_password_pythonic(num_passwords):
    # Генерируем пароли с помощью генератора списков
    passwords = [
        ''.join([random.choice(string.ascii_letters) for _ in range(2)] +
                [random.choice(string.ascii_letters + string.digits) for _ in range(4)])
        for _ in range(num_passwords)
    ]
    return passwords

# Функция для измерения времени выполнения функции
def measure_time(func, num_passwords):
    start_time = timeit.default_timer()            # Запуск таймера
    func(num_passwords)                            # Выполнение функции
    return timeit.default_timer() - start_time     # Возвращение времени выполнения функции

num_passwords = int(input("Введите количество паролей: "))

print("1 часть: Генерация паролей до усложнения")
generated_passwords_1 = generate_password_pythonic(num_passwords)
for i, password in enumerate(generated_passwords_1):
    print(f"Пароль {i+1}: {password}")

# Измерение времени выполнения обеих функций
time_algorithm = measure_time(generate_password_algorithm, num_passwords)
time_pythonic = measure_time(generate_password_pythonic, num_passwords)

# Вывод результатов
print("\nВремя выполнения с использованием алгоритмического подхода:", time_algorithm)
print("Время выполнения с использованием генератора списков:", time_pythonic)

# Функция для вычисления оптимального подхода
def optimal_approach():
    if time_algorithm < time_pythonic:
        print("Алгоритмический подход быстрее")
    elif time_algorithm > time_pythonic:
        print("Подход с использованием генератора списков быстрее")
    else:
        print("Оба подхода выполняются с одинаковой скоростью")

# Вызывание функции для определения оптимального подхода
optimal_approach()

# 2 часть
# Ограничение на характеристики пароля

print("\n2 часть: Генерация паролей с учетом ограничения")
def generate_password_with_constraint(num_passwords):
    passwords = []
    for _ in range(num_passwords):
        password = ''
        password += random.choice(string.ascii_letters)            # Первый символ - латинская буква
        password += random.choice(string.ascii_letters)            # Второй символ - латинская буква
        password += random.choice(string.ascii_letters)            # Ограничиваем третий символ так, чтобы он был только латинскими буквами
        password += ''.join(random.choices(string.digits, k=3))    # Ограничиваем остальные символы так, чтобы они были только цифрами
        passwords.append(password)
    return passwords

# Измеряем время выполнения функции с ограничением
time_with_constraint = measure_time(generate_password_with_constraint, num_passwords)
print("Время выполнения с учетом ограничения:", time_with_constraint)

# Вывод паролей
generated_passwords_2 = generate_password_with_constraint(num_passwords)
for i, password in enumerate(generated_passwords_2):
    print(f"Пароль {i+1}: {password}")
