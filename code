'''
Задание состоит из двух частей.
1 часть – написать программу в соответствии со своим вариантом задания. Написать 2 варианта формирования (алгоритмический и с помощью функций Питона), сравнив по времени их выполнение.
2 часть – усложнить написанную программу, введя по своему усмотрению в условие минимум одно ограничение на характеристики объектов (которое будет сокращать количество переборов)  и целевую функцию для нахождения оптимального  решения.

Пароль состоит из 6 символов. Первые 2 – латинские буквы, остальные - латинские буквы или цифры. Составьте все возможные пароли.
'''
import string
import random
import timeit
import itertools

# Функция для генерации пароля с использованием алгоритмического подхода
def generate_password_algorithm(num_passwords):
    passwords = []
    for _ in range(num_passwords):
        password = ''
        password += random.choice(string.ascii_letters)                   # Первый символ - латинская буква
        password += random.choice(string.ascii_letters)                   # Второй символ - латинская буква
        password += random.choice(string.ascii_letters + string.digits)   # Третий символ - латинская буква или цифра
        password += random.choice(string.ascii_letters + string.digits)   # Четвертый символ - латинская буква или цифра
        password += random.choice(string.ascii_letters + string.digits)   # Пятый символ - латинская буква или цифра
        password += random.choice(string.ascii_letters + string.digits)   # Шестой символ - латинская буква или цифра
        passwords.append(password)
    return passwords

# Функция для генерации пароля с использованием функций Python
def generate_password_pythonic(num_passwords):
    # Генерируем пароли с помощью генератора списков
    passwords = [
        ''.join([random.choice(string.ascii_letters) for _ in range(2)] +
                [random.choice(string.ascii_letters + string.digits) for _ in range(4)])
        for _ in range(num_passwords)
    ]
    return passwords

# Функция для измерения времени выполнения функции
def measure_time(func, num_passwords):
    start_time = timeit.default_timer()            # Запуск таймера
    func(num_passwords)                            # Выполнение функции
    return timeit.default_timer() - start_time     # Возвращение времени выполнения функции

# Указываем количество паролей
num_passwords = 10

print("1 часть: Генерация паролей до усложнения (первые 10 паролей):")
generated_passwords_1 = generate_password_pythonic(num_passwords)
for i, password in enumerate(generated_passwords_1[:10]):
    print(f"Пароль {i+1}: {password}")

# Измеряем время выполнения обеих функций
time_algorithm = measure_time(generate_password_algorithm, num_passwords)
time_pythonic = measure_time(generate_password_pythonic, num_passwords)

# Вывод времени выполнения обеих функций
print("\nВремя выполнения с использованием алгоритмического подхода:", time_algorithm)
print("Время выполнения с использованием генератора списков:", time_pythonic)

# Функция для вычисления оптимального подхода
def optimal_approach():
    if time_algorithm < time_pythonic:
        print("Алгоритмический подход быстрее")
    elif time_algorithm > time_pythonic:
        print("Подход с использованием генератора списков быстрее")
    else:
        print("Оба подхода выполняются с одинаковой скоростью")

# Вызывание функции для определения оптимального подхода
optimal_approach()

# Функция для подсчета количества всех возможных комбинаций пароля
def count_all_possible_passwords():
    num_letters = len(string.ascii_letters)
    num_digits = len(string.digits)
    total_combinations = num_letters ** 4 * (num_letters + num_digits) ** 2
    return total_combinations

# Вывод количества всех возможных комбинаций пароля
print("Количество всех возможных комбинаций пароля:", count_all_possible_passwords())

# 2 часть: Генерация паролей с учетом ограничения
print("\n2 часть: Генерация паролей с учетом ограничения")
def generate_password_with_constraint(num_passwords):
    passwords = []
    for _ in range(num_passwords):
        password = ''
        password += random.choice(string.ascii_letters)            # Первый символ - латинская буква
        password += random.choice(string.ascii_letters)            # Второй символ - латинская буква
        password += random.choice(string.ascii_letters)            # Ограничиваем третий символ так, чтобы он был только латинскими буквами
        password += ''.join(random.choices(string.digits, k=3))    # Ограничиваем остальные символы так, чтобы они были только цифрами
        passwords.append(password)
    return passwords

# Измеряем время выполнения функции с ограничением
time_with_constraint = measure_time(generate_password_with_constraint, num_passwords)
print("Время выполнения с учетом ограничения:", time_with_constraint)

# Вывод первых 10 паролей
generated_passwords_2 = generate_password_with_constraint(num_passwords)
print("Первые 10 паролей с учетом ограничения:")
for i, password in enumerate(generated_passwords_2[:10]):
    print(f"Пароль {i+1}: {password}")

# Функция для подсчета количества всех возможных комбинаций пароля с ограничением
def count_all_possible_passwords_with_constraint():
    num_letters = len(string.ascii_letters)
    total_combinations = num_letters ** 3 * (num_letters + 10) ** 3
    return total_combinations

# Вывод количества всех возможных комбинаций пароля с ограничением
print("\nКоличество всех возможных комбинаций пароля с учетом ограничения:", count_all_possible_passwords_with_constraint())
